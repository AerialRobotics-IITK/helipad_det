// Generated by gencpp from file mav_utils_msgs/BBox.msg
// DO NOT EDIT!


#ifndef MAV_UTILS_MSGS_MESSAGE_BBOX_H
#define MAV_UTILS_MSGS_MESSAGE_BBOX_H


#include <string>
#include <vector>
#include <memory>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>


namespace mav_utils_msgs
{
template <class ContainerAllocator>
struct BBox_
{
  typedef BBox_<ContainerAllocator> Type;

  BBox_()
    : boxID(0)
    , pixSize(0)
    , contourSize(0)
    , colour()
    , diagIndex(0.0)
    , areaIndex(0.0)
    , eigenIndex(0.0)
    , rangeX()
    , rangeY()
    , centre()
    , cornerX()
    , cornerY()
    , eigenVal()
    , eigenVec()
    , contourX()
    , contourY()
    , full(false)
    , store(false)  {
    }
  BBox_(const ContainerAllocator& _alloc)
    : boxID(0)
    , pixSize(0)
    , contourSize(0)
    , colour(_alloc)
    , diagIndex(0.0)
    , areaIndex(0.0)
    , eigenIndex(0.0)
    , rangeX(_alloc)
    , rangeY(_alloc)
    , centre(_alloc)
    , cornerX(_alloc)
    , cornerY(_alloc)
    , eigenVal(_alloc)
    , eigenVec(_alloc)
    , contourX(_alloc)
    , contourY(_alloc)
    , full(false)
    , store(false)  {
  (void)_alloc;
    }



   typedef int32_t _boxID_type;
  _boxID_type boxID;

   typedef int32_t _pixSize_type;
  _pixSize_type pixSize;

   typedef int32_t _contourSize_type;
  _contourSize_type contourSize;

   typedef std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>> _colour_type;
  _colour_type colour;

   typedef float _diagIndex_type;
  _diagIndex_type diagIndex;

   typedef float _areaIndex_type;
  _areaIndex_type areaIndex;

   typedef float _eigenIndex_type;
  _eigenIndex_type eigenIndex;

   typedef std::vector<int32_t, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<int32_t>> _rangeX_type;
  _rangeX_type rangeX;

   typedef std::vector<int32_t, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<int32_t>> _rangeY_type;
  _rangeY_type rangeY;

   typedef std::vector<float, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<float>> _centre_type;
  _centre_type centre;

   typedef std::vector<float, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<float>> _cornerX_type;
  _cornerX_type cornerX;

   typedef std::vector<float, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<float>> _cornerY_type;
  _cornerY_type cornerY;

   typedef std::vector<float, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<float>> _eigenVal_type;
  _eigenVal_type eigenVal;

   typedef std::vector<float, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<float>> _eigenVec_type;
  _eigenVec_type eigenVec;

   typedef std::vector<int32_t, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<int32_t>> _contourX_type;
  _contourX_type contourX;

   typedef std::vector<int32_t, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<int32_t>> _contourY_type;
  _contourY_type contourY;

   typedef uint8_t _full_type;
  _full_type full;

   typedef uint8_t _store_type;
  _store_type store;





  typedef boost::shared_ptr< ::mav_utils_msgs::BBox_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::mav_utils_msgs::BBox_<ContainerAllocator> const> ConstPtr;

}; // struct BBox_

typedef ::mav_utils_msgs::BBox_<std::allocator<void> > BBox;

typedef boost::shared_ptr< ::mav_utils_msgs::BBox > BBoxPtr;
typedef boost::shared_ptr< ::mav_utils_msgs::BBox const> BBoxConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::mav_utils_msgs::BBox_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::mav_utils_msgs::BBox_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::mav_utils_msgs::BBox_<ContainerAllocator1> & lhs, const ::mav_utils_msgs::BBox_<ContainerAllocator2> & rhs)
{
  return lhs.boxID == rhs.boxID &&
    lhs.pixSize == rhs.pixSize &&
    lhs.contourSize == rhs.contourSize &&
    lhs.colour == rhs.colour &&
    lhs.diagIndex == rhs.diagIndex &&
    lhs.areaIndex == rhs.areaIndex &&
    lhs.eigenIndex == rhs.eigenIndex &&
    lhs.rangeX == rhs.rangeX &&
    lhs.rangeY == rhs.rangeY &&
    lhs.centre == rhs.centre &&
    lhs.cornerX == rhs.cornerX &&
    lhs.cornerY == rhs.cornerY &&
    lhs.eigenVal == rhs.eigenVal &&
    lhs.eigenVec == rhs.eigenVec &&
    lhs.contourX == rhs.contourX &&
    lhs.contourY == rhs.contourY &&
    lhs.full == rhs.full &&
    lhs.store == rhs.store;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::mav_utils_msgs::BBox_<ContainerAllocator1> & lhs, const ::mav_utils_msgs::BBox_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace mav_utils_msgs

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsMessage< ::mav_utils_msgs::BBox_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::mav_utils_msgs::BBox_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::mav_utils_msgs::BBox_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::mav_utils_msgs::BBox_<ContainerAllocator> const>
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::mav_utils_msgs::BBox_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::mav_utils_msgs::BBox_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::mav_utils_msgs::BBox_<ContainerAllocator> >
{
  static const char* value()
  {
    return "fd2583954c87e86ec1cf450da38931e5";
  }

  static const char* value(const ::mav_utils_msgs::BBox_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0xfd2583954c87e86eULL;
  static const uint64_t static_value2 = 0xc1cf450da38931e5ULL;
};

template<class ContainerAllocator>
struct DataType< ::mav_utils_msgs::BBox_<ContainerAllocator> >
{
  static const char* value()
  {
    return "mav_utils_msgs/BBox";
  }

  static const char* value(const ::mav_utils_msgs::BBox_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::mav_utils_msgs::BBox_<ContainerAllocator> >
{
  static const char* value()
  {
    return "int32 boxID\n"
"int32 pixSize\n"
"int32 contourSize\n"
"string colour\n"
"float32 diagIndex\n"
"float32 areaIndex\n"
"float32 eigenIndex\n"
"int32[] rangeX\n"
"int32[] rangeY\n"
"float32[] centre\n"
"float32[] cornerX\n"
"float32[] cornerY\n"
"float32[] eigenVal\n"
"float32[] eigenVec\n"
"int32[] contourX\n"
"int32[] contourY\n"
"bool full\n"
"bool store\n"
;
  }

  static const char* value(const ::mav_utils_msgs::BBox_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::mav_utils_msgs::BBox_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.boxID);
      stream.next(m.pixSize);
      stream.next(m.contourSize);
      stream.next(m.colour);
      stream.next(m.diagIndex);
      stream.next(m.areaIndex);
      stream.next(m.eigenIndex);
      stream.next(m.rangeX);
      stream.next(m.rangeY);
      stream.next(m.centre);
      stream.next(m.cornerX);
      stream.next(m.cornerY);
      stream.next(m.eigenVal);
      stream.next(m.eigenVec);
      stream.next(m.contourX);
      stream.next(m.contourY);
      stream.next(m.full);
      stream.next(m.store);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct BBox_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::mav_utils_msgs::BBox_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::mav_utils_msgs::BBox_<ContainerAllocator>& v)
  {
    s << indent << "boxID: ";
    Printer<int32_t>::stream(s, indent + "  ", v.boxID);
    s << indent << "pixSize: ";
    Printer<int32_t>::stream(s, indent + "  ", v.pixSize);
    s << indent << "contourSize: ";
    Printer<int32_t>::stream(s, indent + "  ", v.contourSize);
    s << indent << "colour: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>>>::stream(s, indent + "  ", v.colour);
    s << indent << "diagIndex: ";
    Printer<float>::stream(s, indent + "  ", v.diagIndex);
    s << indent << "areaIndex: ";
    Printer<float>::stream(s, indent + "  ", v.areaIndex);
    s << indent << "eigenIndex: ";
    Printer<float>::stream(s, indent + "  ", v.eigenIndex);
    s << indent << "rangeX[]" << std::endl;
    for (size_t i = 0; i < v.rangeX.size(); ++i)
    {
      s << indent << "  rangeX[" << i << "]: ";
      Printer<int32_t>::stream(s, indent + "  ", v.rangeX[i]);
    }
    s << indent << "rangeY[]" << std::endl;
    for (size_t i = 0; i < v.rangeY.size(); ++i)
    {
      s << indent << "  rangeY[" << i << "]: ";
      Printer<int32_t>::stream(s, indent + "  ", v.rangeY[i]);
    }
    s << indent << "centre[]" << std::endl;
    for (size_t i = 0; i < v.centre.size(); ++i)
    {
      s << indent << "  centre[" << i << "]: ";
      Printer<float>::stream(s, indent + "  ", v.centre[i]);
    }
    s << indent << "cornerX[]" << std::endl;
    for (size_t i = 0; i < v.cornerX.size(); ++i)
    {
      s << indent << "  cornerX[" << i << "]: ";
      Printer<float>::stream(s, indent + "  ", v.cornerX[i]);
    }
    s << indent << "cornerY[]" << std::endl;
    for (size_t i = 0; i < v.cornerY.size(); ++i)
    {
      s << indent << "  cornerY[" << i << "]: ";
      Printer<float>::stream(s, indent + "  ", v.cornerY[i]);
    }
    s << indent << "eigenVal[]" << std::endl;
    for (size_t i = 0; i < v.eigenVal.size(); ++i)
    {
      s << indent << "  eigenVal[" << i << "]: ";
      Printer<float>::stream(s, indent + "  ", v.eigenVal[i]);
    }
    s << indent << "eigenVec[]" << std::endl;
    for (size_t i = 0; i < v.eigenVec.size(); ++i)
    {
      s << indent << "  eigenVec[" << i << "]: ";
      Printer<float>::stream(s, indent + "  ", v.eigenVec[i]);
    }
    s << indent << "contourX[]" << std::endl;
    for (size_t i = 0; i < v.contourX.size(); ++i)
    {
      s << indent << "  contourX[" << i << "]: ";
      Printer<int32_t>::stream(s, indent + "  ", v.contourX[i]);
    }
    s << indent << "contourY[]" << std::endl;
    for (size_t i = 0; i < v.contourY.size(); ++i)
    {
      s << indent << "  contourY[" << i << "]: ";
      Printer<int32_t>::stream(s, indent + "  ", v.contourY[i]);
    }
    s << indent << "full: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.full);
    s << indent << "store: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.store);
  }
};

} // namespace message_operations
} // namespace ros

#endif // MAV_UTILS_MSGS_MESSAGE_BBOX_H
